{
  "metadata": {
    "type": "task",
    "status": "active",
    "priority": "high",
    "parent_project": "2025-06-29_define-project-requirements",
    "created": "2025-06-28T21:28:53Z",
    "updated": "2025-06-28T21:28:53Z",
    "title": "Define project requirements",
    "description": "Implementation task template",
    "template_version": "1.1"
  },
  "details": {
    "task_name": "Define project requirements",
    "objective_value": {
      "what": "{{IMPLEMENTATION_GOAL}}",
      "why": "Enables {{TARGET_USER}} to {{USER_GOAL}}",
      "done_when": "User can {{SPECIFIC_ACTION}} without errors"
    },
    "context": {
      "project": "{{PARENT_PROJECT}}",
      "user_story": "As {{TARGET_USER}}, I want to {{USER_GOAL}} so that {{BENEFIT}}",
      "deliverable": "Working code that {{MEASURABLE_OUTCOME}}"
    },
    "implementation_plan": {
      "approach": "{{APPROACH}}",
      "dependencies": "{{DEPENDENCIES}}",
      "testing": "{{TEST_STRATEGY}}"
    },
    "steps": [
      {
        "description": "Setup: Load design from RAG + verify dependencies",
        "status": "pending"
      },
      {
        "description": "Core logic: Implement main functionality (no edge cases)",
        "status": "pending"
      },
      {
        "description": "Happy path test: Verify basic functionality works",
        "status": "pending"
      },
      {
        "description": "Edge cases: Handle errors + validate inputs",
        "status": "pending"
      },
      {
        "description": "Integration: Connect to existing code + full test suite",
        "status": "pending"
      },
      {
        "description": "Polish: Refactor + document + commit working code",
        "status": "pending"
      }
    ],
    "success_criteria": [
      "Feature works as designed",
      "Tests pass",
      "Code is clean and documented",
      "User can use the feature"
    ],
    "instructions": {
      "inherits_from": "base_task.md workflow",
      "implementation_specific": [
        "Load design decisions before starting",
        "Follow existing code patterns",
        "Test each step before moving on",
        "Commit working code frequently",
        "Document technical debt immediately"
      ],
      "implementation_queries": [
        "Before implementing: rag_memory___hybridSearch query=\"{{PARENT_PROJECT}} design architecture decisions\"",
        "Before implementing: rag_memory___searchNodes query=\"type:design parent:{{PARENT_PROJECT}}\"",
        "After each step: rag_memory___createEntities entities=[{\"name\": \"impl_step_{{TIMESTAMP}}\", \"type\": \"implementation_detail\", \"properties\": {\"feature\": \"[what built]\", \"pattern\": \"[pattern used]\", \"debt\": \"[any shortcuts]\"}}}]"
      ],
      "quality_gates": [
        "All tests pass",
        "Code reviewed against standards",
        "No critical TODOs",
        "Performance validated",
        "Documentation complete"
      ]
    },
    "placeholders_guide": {
      "IMPLEMENTATION_GOAL": {
        "type": "string",
        "description": "The specific goal of this implementation task."
      },
      "TARGET_USER": {
        "type": "string",
        "description": "The target user for this feature."
      },
      "USER_GOAL": {
        "type": "string",
        "description": "What the user wants to achieve."
      },
      "SPECIFIC_ACTION": {
        "type": "string",
        "description": "A specific action the user can perform."
      },
      "PARENT_PROJECT": {
        "type": "string",
        "description": "The parent project of this task."
      },
      "BENEFIT": {
        "type": "string",
        "description": "The benefit for the user."
      },
      "MEASURABLE_OUTCOME": {
        "type": "string",
        "description": "A measurable outcome of the implementation."
      },
      "APPROACH": {
        "type": "string",
        "description": "The technical approach for implementation."
      },
      "DEPENDENCIES": {
        "type": "string",
        "description": "Technical dependencies."
      },
      "TEST_STRATEGY": {
        "type": "string",
        "description": "Testing strategy."
      }
    },
    "project_name": "Define project requirements"
  },
  "workflow_guidance": {
    "before_starting": {
      "description": "Before starting:",
      "steps": [
        "# Load context from similar tasks",
        "rag_memory___hybridSearch query=\"{{TITLE}} similar tasks patterns\"",
        "rag_memory___searchNodes query=\"type:task status:completed similar:{{TITLE}}\"",
        "# Create task entity and link to project",
        "rag_memory___createEntities entities=[{\"name\": \"task_{{TITLE}}\", \"type\": \"task\", \"properties\": {\"objective\": \"{{TASK_OBJECTIVE}}\", \"parent_project\": \"{{PARENT_PROJECT}}\"}}}]",
        "rag_memory___createRelations relations=[{\"from\": \"project_{{PARENT_PROJECT}}\", \"to\": \"task_{{TITLE}}\", \"type\": \"contains\"}]"
      ]
    },
    "step_execution": {
      "description": "For EVERY step:",
      "steps": [
        "1. BEFORE starting:",
        "- Query patterns: rag_memory___hybridSearch query=\"[step description] best practices\"",
        "- Create step entity in RAG",
        "2. DURING execution:",
        "- Document blockers immediately in task file",
        "- If blocked >1hr: Query RAG for similar blockers and solutions",
        "3. AFTER completion:",
        "- Update step: Mark #status:completed",
        "- Store results:",
        "rag_memory___createEntities entities=[{\"name\": \"step_{{DATE}}_[step_num]\", \"type\": \"completed_step\", \"properties\": {\"blockers\": \"[any blockers]\", \"output\": \"[deliverable]\", \"lessons\": \"[key learning]\"}}}]",
        "- If significant learning: Add to CRITICAL_FINDINGS.md"
      ]
    },
    "progress_check": {
      "description": "After completing 3 steps:",
      "steps": [
        "- Query: rag_memory___hybridSearch query=\"my recent steps velocity blockers\"",
        "- Identify patterns in execution",
        "- Adjust approach if needed",
        "- Update estimates for remaining steps"
      ]
    },
    "task_completion": {
      "description": "When all steps complete:",
      "steps": [
        "1. Calculate total metrics (blockers)",
        "2. Document key outcomes in CURRENT_IMPLEMENTATION.json",
        "3. Store and process complete task:",
        "# Store document",
        "rag_memory___storeDocument id=\"task_{{TITLE}}_complete\" content=\"[full task content]\"",
        "# Process for search",
        "rag_memory___chunkDocument documentId=\"task_{{TITLE}}_complete\"",
        "rag_memory___embedChunks documentId=\"task_{{TITLE}}_complete\"",
        "rag_memory___extractTerms documentId=\"task_{{TITLE}}_complete\"",
        "rag_memory___linkEntitiesToDocument documentId=\"task_{{TITLE}}_complete\" entityNames=[\"task_{{TITLE}}\"]",
        "# Update entity",
        "rag_memory___updateEntity name=\"task_{{TITLE}}\" properties={\"status\": \"completed\"}",
        "4. For each critical finding:",
        "- Add 1-line to CRITICAL_FINDINGS.md: \"Finding description â†’ keywords\"",
        "- Execute FULL PIPELINE in CRITICAL_FINDINGS.md protocol"
      ]
    },
    "common_pitfalls": [
      "AVOID these patterns:",
      "Starting step without clear success criteria",
      "Skipping RAG queries \"to save time\"",
      "Not documenting blockers immediately",
      "Batching commits (commit after each working step)",
      "Estimating without checking historical data",
      "Working >2hrs without updating CURRENT_IMPLEMENTATION.json"
    ]
  }
}
